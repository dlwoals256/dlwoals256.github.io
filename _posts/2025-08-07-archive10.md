---
title: 코드트리 문제풀이[옛날에 푼 거 정리(10)]
date: 2025-08-07
categories: [Problem Solving]
tags: [코딩테스트, 코드트리]
description: 나누고 빼면서 합하기, 출력결과 84, 출력결과 85, 함수를 이용한 부분 문자열의 위치 구하기
toc: false
comments: false
math: true
mermaid: false
---

# 문제

| 유형 | 문제 링크 | 난이도 |
| --- | --- | --- |
| [Trail 2 / 함수 / 변수의 영역](https://www.codetree.ai/trail-info/novice-mid/) | [[Challenge]나누고 빼면서 합하기](https://www.codetree.ai/trails/complete/curated-cards/challenge-divide-and-subtract-and-add-up/) | 쉬움 |
| [Trail 2 / 함수 / 변수의 영역](https://www.codetree.ai/trail-info/novice-mid/) | [[Concept]출력결과 84](https://www.codetree.ai/trails/complete/curated-cards/intro-reading-84/) | 쉬움 |
| [Trail 2 / 함수 / 변수의 영역](https://www.codetree.ai/trail-info/novice-mid/) | [[Concept]출력결과 85](https://www.codetree.ai/trails/complete/curated-cards/intro-reading-85/) | 쉬움 |
| [Trail 2 / 함수 / 변수의 영역](https://www.codetree.ai/trail-info/novice-mid/) | [[Concept]함수를 이용한 부분 문자열의 위치 구하기](https://www.codetree.ai/trails/complete/curated-cards/intro-find-the-location-of-a-substring-using-a-function/) | 쉬움 |

---------------------------------------

# 나누고 빼면서 합하기

## 문제 설명

$N$ 개의 원소로 이루어진 수열 $A$ 가 주어지고, 정수 $M$ 이 주어질 때, $M$ 이 $1$ 이 될 때까지 $M$ 이 홀수면 $1$ 을 빼고 짝수면 $2$ 로 나누는 걸 반복하며 $A$ 의 $M$ 번째 원소를 계속 더해 출력합니다.

## 풀이

뭔가 말이 이해가 안 될 수 있는데, $M$ 은 인덱스입니다. 인덱스가 홀수면 1을 빼고 짝수면 2로 나누는 걸 반복하는 겁니다.

## 코드

```cpp

#include <iostream>

using namespace std;

int n, m;
int A[100];


int main() {
    cin >> n >> m;

    for (int i = 0; i < n; i++) {
        cin >> A[i];
    }

    int sum = 0;

    while (m >= 1) {
        sum += A[m-1];
        if (m % 2 != 0) {
            m--;
        } else {
            m /= 2;
        }
    }

    cout << sum;

    return 0;
}

```

---------------------------------------

# 출력결과 84

## 문제 설명

다음 코드 1과 코드 2의 출력 결과를 묻습니다. 5지선다입니다.

```cpp

int f(int n) {  
    for(int i = 1; i <= n; i++)
        product *= i;
}

int main() {
    int product = 1;
    f(5);
    cout << product;
}

```

```cpp

int arr[] = {1, 2, 3, 4, 5};
int f(int n) {  
    int product = 1;
    for(int i = 0; i < n; i++)
        product *= arr[i];
    return product;
}

int main() {
    cout << f(5);
}

```

## 풀이

코드 1은 `f`의 scope에 `product`가 없어서 에러가 발생하고 코드 2는 정상 작동 합니다. 따라서 정답은 `코드 1은 에러가 발생, 코드 2는 120` 입니다.

---------------------------------------

# 출력결과 85

## 문제 설명

다음 코드의 출력 결과를 묻습니다. 5지선다입니다.

```cpp

int num = 5;

void g() {
    cout << num << " ";
}
void f() {  
    int num = 9;
    while(num < 8)
        num++;
    cout << num << " ";
    g();
}

int main() {
    f();

    cout << num;
    return 0;
}


```

## 풀이

저는 이거 틀렸었는데, 함수 스코프랑 블록 스코프에 대해서 제대로 알고 있는 줄 알았지만, 함수 내에 선언된 변수가 있고 그 함수 내에서 또 다른 함수를 부르게 되면 원래 호출한 함수에 그 내부에 있는 함수의 스코프가 포함되는 게 아니라, 그냥 외부 함수 내부 함수 두 함수에 모두 별도의 스코프가 존재하게 되는 거라 `f` 안에서 `num`을 변화시켜도 `g`로 넘어가면 아예 다른 스코프이기 때문에 `g`에서는 전역에 있는 `num`을 참조하게 되는 겁니다.  

정답은 `9 5 5` 입니다.

---------------------------------------

# 함수를 이용한 부분 문자열의 위치 구하기

## 문제 설명

주어진 입력 문자열에 대해서 부분 문자열이 함께 주어지고 부분 문자열이 존재하면 입력 문자열에서의 시작 인덱스를 리턴하고 없으면 `-1`을 리턴합니다.

## 풀이

포인트는 부분 문자열을 찾는 함수를 쓰지 않고 만들어보기에 맞춰봤는데, 내부 루프에서 원래 문자열 인덱스 `i`에 부분 문자열 인덱스 `j`를 더해주는 걸 주목해보면 되겠습니다.

## 코드

```cpp

#include <iostream>
#include <string>

using namespace std;

string text;
string pattern;

int strstr(string str, string substr) {
    for (int i = 0; i < str.size(); i++) {
        if (substr[0] == str[i]) {
            for (int j = 0; j < substr.size(); j++) {
                if (substr[j] != str[i + j]) break;
                if (j == substr.size() - 1) {
                    return i;
                }
            }
        }
    }

    return -1;
}

int main() {
    cin >> text;
    cin >> pattern;

    cout << strstr(text, pattern);

    return 0;
}

```
