---
title: 코드트리 문제풀이[옛날에 푼 거 정리(6)]
date: 2025-07-29 12:11:50 +0900
categories: [Problem Solving]
tags: [코딩테스트, 코드트리]
description: 함수를 이용한 온전수 판별, 함수를 이용한 합과 소수 판별
toc: false
comments: false
math: true
mermaid: false
---

# 문제

| 유형 | 문제 링크 | 난이도 |
| --- | --- | --- |
| [Trail 2 / 함수 / 값을 반환하는 함수](https://www.codetree.ai/trail-info/novice-mid/) | [[Challenge]함수를 이용한 온전수 판별](https://www.codetree.ai/trails/complete/curated-cards/challenge-determining-the-whole-number-using-a-function/) | 쉬움 |
| [Trail 2 / 함수 / 값을 반환하는 함수](https://www.codetree.ai/trail-info/novice-mid/) | [[Challenge]함수를 이용한 합과 소수 판별](https://www.codetree.ai/trails/complete/curated-cards/challenge-use-functions-to-determine-sums-and-decimals/) | 보통 |

---------------------------------------

![공사중](/assets/post_assets/공사중.jpg)

# 함수를 이용한 온전수 판별

## 문제 설명

정수 $A$와 $B$가 주어지면 $A$이상 $B$이하 온전수의 개수를 셉니다. 온전수는 다음과 같은 수를 말합니다:

1. 2로 나누어떨어지는 수
2. 일의 자리가 5인 수
3. 3으로 나누어떨어지는데 9로는 나누어떨어지지 않는 수

## 코드

```cpp

#include <iostream>

using namespace std;

int a, b;

bool isMeets(int x) {
    if (x % 2 == 0) return false;
    if (x % 10 == 5) return false;
    if (x % 3 == 0 && x % 9 != 0) return false;
    return true;
}

int main() {
    cin >> a >> b;

    int cnt = 0;

    for (int i = a; i <= b; i++) {
        if (isMeets(i)) cnt++;
    }

    cout << cnt;

    return 0;
}

```

---------------------------------------

# 함수를 이용한 합과 소수 판별

## 문제 설명

정수 $A$와 $B$가 주어지면 $A$이상 $B$이하의 수 중 소수이면서 모든 자릿수의 합이 짝수인 수의 개수를 셉니다.

## 코드

```cpp

#include <iostream>

using namespace std;

int a, b;
int nums[101];

void init_() {
    for (int i = 1; i <= 100; i++) {
        nums[i] = i;
    }

    for (int i = 2; i <= 10; i++) {
        if (i == 0) continue;

        for (int j = i * 2; j <= 100; j += i) {
            nums[j] = 0;
        }
    }
}

bool scanDigit(int n) {
    int digitSum = 0;
    while (n) {
        digitSum += (n % 10);
        n /= 10;
    }

    return digitSum % 2 == 0;
}

int main() {
    cin >> a >> b;

    init_();
    int cnt = 0;
    for (int i = a; i <= b; i++) {
        if (nums[i] != 0 && scanDigit(i)) cnt++;
    }

    cout << cnt;

    return 0;
}

```

`a` 이상, `b`이하를 돌면서 소수인지와 자릿수 합이 짝수인지를 만족하면 cnt를 증가시킵니다.

### 개념플러스

{% include callout.html title="에라토스테네스의 체(Sieve of Eratosthenes)" type="note" content="
    에라토스테네스의 체는 소수를 구하기 위해서 수행하는 이 수 $n$이 어떤 다른 수로 나누어떨어지는가?를 검사하기 위해 $n$ 이하의 모든 양의 정수에 대해 반복을 수행하는 횟수를 $O(n)$ 에서 $O(n \log \log n)$ 까지 줄일 수 있는 알고리즘입니다. 기본 아이디어는 **모든 합성수는 반드시 어떤 소수의 배수이다. 따라서 작은 소수들의 배수들을 지우면 나머지는 모두 소수이다**에서 출발합니다. $n$까지의 소수를 구하는 과정은 다음과 같습니다:

    1. 길이 `n`의 배열을 `true`로 초기화

" %}

{% include callout.html title="나아가서?" type="note" content="
    OJ(Online Judge) 같은 데에서 다루는 $10^7$ 수준의 소수로는 에라토스테네스의 체면 충분합니다. 딱 적당하죠. 그런데 그 이상은? RSA(Rivest-Shamir-Adleman, RSA) 암호 같은 데에서 쓰이는 터무니 없는 수준의 소수는? 라는 질문에서 시작해 소수 판정(Primality test)이라는 주제로 넘어가면 확률적 방법과 결정적 방법에 대해 찾아볼 수 있겠습니다. 심심해서 찾아본 내용은 확률적 방법으론 Miller-Rabin primality test가 있고 결정적 방법으론 ECPP(Elliptic Curve Primality Prooving)이라는 게 있다고 보았네요.
" %}

