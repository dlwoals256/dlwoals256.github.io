---
title: 코드트리 문제풀이[옛날에 푼 거 정리(12)]
date: 2025-08-09 12:11:50 +0900
categories: [Problem Solving]
tags: [코딩테스트, 코드트리]
description: 반복 출력하기 2, 숫자 차례로 출력하기, 재귀함수를 이용한 별 출력, 출력결과 81
toc: false
comments: false
math: true
mermaid: false
---

# 문제

| 유형 | 문제 링크 | 난이도 |
| --- | --- | --- |
| [Trail 2 / 재귀함수 / 값을 반환하지 않는 재귀함수](https://www.codetree.ai/trail-info/novice-mid/) | [[Concept]반복 출력하기 2](https://www.codetree.ai/trails/complete/curated-cards/intro-repeated-output-2/) | 쉬움 |
| [Trail 2 / 재귀함수 / 값을 반환하지 않는 재귀함수](https://www.codetree.ai/trail-info/novice-mid/) | [[Concept]숫자 차례로 출력하기](https://www.codetree.ai/trails/complete/curated-cards/intro-to-output-numerically/) | 쉬움 |
| [Trail 2 / 재귀함수 / 값을 반환하지 않는 재귀함수](https://www.codetree.ai/trail-info/novice-mid/) | [[Challenge]재귀함수를 이용한 별 출력](https://www.codetree.ai/trails/complete/curated-cards/challenge-star-output-with-recursive-function/) | 쉬움 |
| [Trail 2 / 재귀함수 / 값을 반환하지 않는 재귀함수](https://www.codetree.ai/trail-info/novice-mid/) | [[Challenge]출력결과 81](https://www.codetree.ai/trails/complete/curated-cards/challenge-reading-k201838/) | 보통 |

---------------------------------------

# 개념 설명

재귀함수는 어떤 함수가 자기 자신의 호출을 선언부에 포함하는 함수를 말합니다. 모든 재귀함수는 반복문으로 표현 가능합니다. 재귀함수를 쓰는 이유에는 로직의 표현을 단순하고 명료하게 쓸 수 있어 가독성이 좋아진다가 있는데, 이것이 주 목적이자 가장 큰 장점이라 이 장점이 잘 살려지지 않는 경우는 그냥 반복문으로 처리하는 게 가장 좋고, 특정 자료구조나 알고리즘처럼 시간 복잡도나 공간 복잡도가 안정적이라고 증명된 구현 이외에는 잘 사용하진 않습니다. 그리고 **반드시 재귀 탈출 조건과 탈출 조건으로 근접하는 인자를 명시**해야 합니다.

---------------------------------------

# 반복 출력하기 2

## 문제 설명

$N$ 이 주어지면 문자열 "HelloWorld"를 $N$ 번 출력하는 프로그램을 재귀함수로 짭니다.

## 코드

```cpp

#include <iostream>

using namespace std;

int N;

void print(int n) {
    if (n < 1) return;
    cout << "HelloWorld" << '\n';
    print(--n);
}

int main() {
    cin >> N;

    print(N);

    return 0;
}

```

---------------------------------------

# 숫자 차례로 출력하기

## 문제 설명

$N$ 이 주어지면 재귀함수를 두 개 작성해서 하나는 $1$ 부터 $N$ 까지 숫자를 차례로 출력하고 다른 하나는 $N$부터 $1$ 까지 숫자를 차례로 출력하는 프로그램을 짭니다. 단 두 재귀함수 모두 인자로 $N$ 을 넘깁니다.

## 풀이

재귀함수는 직접 콜 스택을 그려가며 푸는 게 가장 좋습니다. 연습장에 휘갈겨 써서 올리진 않겠습니다. 이 문제는 재귀함수 호출부와 출력부의 순서 차이로 오름차순과 내림차순 출력을 구현합니다. 아래 코드에서 `print_col_asc`가 호출되면 1보다 큰 `n`이 전달되고, 내부에서 즉시 `print_col_asc(n-1)`을 만나게 됩니다. 여기서 `if`문이 앞에서 말한 **재귀 탈출 조건**에 해당하고, `n-1`부분이 **탈출 조건으로 근접하는 인자**를 말합니다. 만난 이후 1 작은 `n`으로 다시 `print_col_asc`를 수행하며, 여기까지 아무런 출력도 없습니다. `N`이 5라고 가정했을 때, 파라미터 n이 1까지 줄어들다가 한 번 더 호출되면 `n`이 0이 되고, `return`을 만나 `n == 1` 일 때의 콜 스택으로 돌아오고, 1을 출력한 후 함수가 종료되며 `n == 2`의 콜 스택으로 돌아와 2를 출력하기를 반복합니다. 즉, `1 2 3 4 5`를 출력하며 오름차순 출력이 완료됩니다.

## 코드

```cpp

#include <iostream>

using namespace std;

int N;


void print_col_asc(int n) {
    if (n < 1) return;
    print_col_asc(n-1);
    cout << n << ' ';
}

void print_col_desc(int n) {
    if (n < 1) return;
    cout << n << ' ';
    print_col_desc(n-1);
}

void print_row(int n) {
    print_col_asc(n);
    cout << '\n';
    print_col_desc(n);
}


int main() {
    cin >> N;

    print_row(N);

    return 0;
}

```

---------------------------------------

# 재귀함수를 이용한 별 출력

## 문제 설명

$N$ 번째 줄까지 다음 모양으로 별을 찍습니다.

```

*
**
***
****
*****

```

## 풀이

재귀함수가 몇 개 필요한가의 기준을 세울 때, 반복문을 기준으로 세워보면 좋습니다. 위와 같은 별을 찍기 위해서는 반복문 내에 반복문을 또 만드는 이중 `for`문으로 구성하게 되는데, 재귀함수의 경우에는 그럼 두 개를 두게 되는 형식으로 생각하면 편합니다.

## 코드

```cpp

#include <iostream>

using namespace std;

int n;

void print_col(int n) {
    if (n < 1) return;
    print_col(n-1); // n-1번까지 함
    cout << '*';
}

void print_row(int n) {
    if (n < 1) return;
    print_row(n-1);
    print_col(n);
    cout << '\n';
}

int main() {
    cin >> n;

    print_row(n);

    return 0;
}

```

---------------------------------------

# 출력결과 81

## 문제 설명

다음 프로그램의 출력 결과를 묻습니다.

```cpp

void f(int a[], int t, int l) {  
    if (t >= l)  
      return;  
    cout << a[t] << " ";
    f(a, t + 1, l);  
    cout << a[t] << " ";
}
int main() {
    int a[10] = {1, 2, 3, 4, 5, 6, 7, 8, 9};
    int n, i;
    n = 10;
    f(a, 0, n);
    return 0;
}

```

## 풀이

t가 인덱스이고 0부터 시작합니다. 그리고 C++에서 배열 크기를 10으로 해놓고 앞의 아홉 개만 초기화하면 자동으로 나머지 한 개는 0이 되기 때문에 위 코드는 오름차순 한 번 내림차순 한 번을 출력하게 되어 정답은 `1 2 3 4 5 6 7 8 9 0 0 9 8 7 6 5 4 3 2 1`입니다.

## 코드플러스

{% include callout.html title="`if`문으로 표현하고자 하는 것" type="note" content="조건문을 읽을 때 편하게 읽는 팁이 굳이 있다면, `if`문의 조건이 만족될 때 **내부에서 뭘 표현하냐에 따라**를 기준으로 읽어보면 좋겠습니다. 즉, 위와 같은 코드에선, `t >= l`이 되는데, 단순히 `t`가 `l`보다 크거나 같다가 아니라, **`t`가 `l`보다 작을 때 원하는 로직을 실행하겠다**라고 생각하면 편합니다." %}