---
title: 코드트리 문제풀이[옛날에 푼 거 정리(4)]
date: 2025-08-01 12:11:50 +0900
categories: [Problem Solving]
tags: [코딩테스트, 코드트리]
description: 함수를 이용한 소수 판별, 함수를 이용한 윤년 판별
toc: false
comments: false
math: true
mermaid: false
---

# 문제

| 유형 | 문제 링크 | 난이도 |
| --- | --- | --- |
| [Trail 2 / 함수 / 값을 반환하는 함수](https://www.codetree.ai/trail-info/novice-mid/) | [[Concept]함수를 이용한 소수 판별](https://www.codetree.ai/trails/complete/curated-cards/intro-decimal-decisions-using-functions/) | 쉬움 |
| [Trail 2 / 함수 / 값을 반환하는 함수](https://www.codetree.ai/trail-info/novice-mid/) | [[Concept]함수를 이용한 윤년 판별](https://www.codetree.ai/trails/complete/curated-cards/intro-tell-the-function-using-a-leap-year/) | 쉬움 |

---------------------------------------

## 개념 설명

이 문제의 개념 섹션에서 **"문제를 Top-down으로 생각하기"**라는 주제를 다뤘습니다. 이 주제가 객체지향의 5원칙(SOLID) 중의 S, Single-responsibility라는 것과 일맥상통하는데 간단히 말하자면 "각 함수는 하나의 명확한 책임을 가지고 있다"라는 것입니다. 즉, 다시 말해, 함수 당 하나의 기능만 동작하도록 작성하는 것이 코드 가독성이나 유지보수 및 디버깅 측명에서 좋다고 하는 게 Single-responsibility입니다. 이걸 생각하면서 함수든 메소드든 짜면 해당 함수나 메소드가 수행하는 일이 명확해지고 코드의 가독성이 높아져서 수정도 간편하게 되는데, 문제풀이에도 비슷하게 아이디어를 착안해올 수 있습니다. 이걸 생각해보며 코드를 짜봤습니다.  

---------------------------------------

# 함수를 이용한 소수 판별

## 문제 설명

정수 $A$와 $B$가 주어지면, $A$ 이상 $B$ 이하 소수들의 합을 구하는 함수를 짭니다. $2 \le A \le B \le 100$ 입니다.

## 풀이

우선, 소수를 구하는 알고리즘으로 유명한 에라토스테네스의 체(Sieve of Eratosthenes)라는 게 있습니다. 하지만 그런 방법 이전에, 그냥 소수를 구해야하는 기본적인 알고리즘부터 구현할 줄 알아야 한다고 생각했고, 그리고 그 이전에 문제에서 애초에 입력 범위가 100 이하이니 기본적으로 소수의 조건을 만족하는 수를 찾아서 반환하는 식으로 해도 되겠지요. 저는 `bool`을 반환하는 `isPrime`을 정의했습니다. argument로 전달된 수가 소수이면 `true`, 소수가 아니면 `false`로 했습니다.

## 코드

```cpp

#include <iostream>

using namespace std;

int a, b;

bool isPrime(int x) {
    bool prime = true;

    for (int i = 2; i < x; i++) 
        if (x % i == 0)
            prime = false;

    return prime;
}

int main() {
    cin >> a >> b;

    int sum = 0;
    for (int i = a; i <= b; i++) {
        if (isPrime(i)) sum += i;
    }

    cout << sum;

    return 0;
}

```

### 코드플러스

{% include callout.html title="flag 변수" type="note" content="내부에 `prime`이라는 변수를 둡니다. 저걸 두게 되면 `return`으로 `true` 혹은 `false`라는 bool 리터럴을 일일이 각 경우(`if`로 분기되는 상황 등)마다 줄 필요 없이 언제나 `return prime`만 하면 됩니다. 내부에서는 그냥 소수 조건을 위배하면 `prime = false`로 하고, 아니면 `prime = true`로만 바꿔주면 끝인 거죠." %}

{% include callout.html title="flag의 초기값" type="note" content="`isPrime`이라는 함수는 **어떤 수로 나누어떨어지는가?**를 내부적으로 검사합니다. 즉, **소수가 아닌가?** 를 내부 `for`문에서 검사하고 있습니다. 이는 소수의 조건인 **어느 하나라도 나누어떨어지는 수가 있으면 소수가 아니다**를 표현하기에, 뭔가 하나 나누어떨어지면 `false`로 표현하는 게 좀 더 가독성있고 이해하기 쉽습니다. 그런 관점에서, 안에서 아무 것도 나누어떨어지지 않고 끝까지 다 해서 빠져나왔으면 그대로 `true`라는 걸 표현하기 위해 저렇게 작성했습니다." %}


---------------------------------------

# 함수를 이용한 윤년 판별

## 문제 설명

$y$가 주어지면, $y$년이 윤년인지 아닌지 판별하는 함수를 짭니다. 윤년의 조건은 다음과 같습니다:  

1. 4로 나누어떨어지는 해는 윤년, 그 밖의 해는 평년입니다.
2. 100으로 나누어떨어지는 해는 평년입니다.
3. 400으로 나누어떨어지는 해는 윤년입니다.

## 풀이

좀 많이 헷갈렸는데, 그냥 일반적으로 우리의 일생 동안은 4년에 한 번씩이라고 보면 되나 100년 단위를 생각할 때에는, 100으로만 나누어 떨어지면(2100, 1900, 2300, ...) 그냥 평년이고 여기서 400으로 나누어떨어지면(2000, 2200, 2400, ...) 윤년이라는 겁니다.

> The Gregorian calendar, the world's most widely used civil calendar, makes a further adjustment for the small error in the Julian algorithm; this extra leap day occurs in each year that is a multiple of 4, except for years evenly divisible by 100 but not by 400. Thus 1900 was not a leap year but 2000 was. - Wikipidia -

코드는 이렇게 표현했습니다:

1. 4로 나누어떨어지는가? Yes → true → next if \| No → false → return
2. 4로 나누어떨어지고 100으로 나누어떨어지는가? Yes → false → next if \| No → true → return
3. 4로 나누어떨어지고 100으로 나누어떨어지는데 400으로도 나누어떨어지나? Yes → true → return \| No → false → return

## 코드

```cpp

#include <iostream>

using namespace std;

int y;

bool is_leap(int y) {
    bool res = false;
    if (y % 4 == 0) {
        res = true;
        if (y % 100 == 0) {
            res = false;
            if (y % 400 == 0) {
                res = true;
            };
        }
    }

    return res;
}

int main() {
    cin >> y;

    if (isLeap(y)) cout << "true";
    else cout << "false";

    return 0;
}

```

---------------------------------------

# Reference

- [Leap year - Wikipidia](https://en.wikipedia.org/wiki/Leap_year)

- [SOLID principle - Digital Ocean](https://www.digitalocean.com/community/conceptual-articles/s-o-l-i-d-the-first-five-principles-of-object-oriented-design)