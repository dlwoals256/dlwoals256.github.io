---
title: 코드트리 문제풀이[옛날에 푼 거 정리(3)]
date: 2025-07-31
categories: [Problem Solving]
tags: [코딩테스트, 코드트리]
description: 정수의 최솟값, 짝수이면서 합이 5의 배수인 수, 함수를 이용한 369 게임, 출력결과 14, 출력결과 46, 출력결과 51, 출력결과 83
toc: false
comments: false
math: true
mermaid: false
---

# 문제

| 유형 | 문제 링크 | 난이도 |
| --- | --- | --- |
| [Trail 2 / 함수 / 값을 반환하는 함수](https://www.codetree.ai/trail-info/novice-mid/) | [[Concept]정수의 최솟값](https://www.codetree.ai/trails/complete/curated-cards/intro-minimum-value-of-an-integer/) | 쉬움 |
| [Trail 2 / 함수 / 값을 반환하는 함수](https://www.codetree.ai/trail-info/novice-mid/) | [[Concept]짝수이면서 합이 5의 배수인 수](https://www.codetree.ai/trails/complete/curated-cards/intro-an-even-number-with-a-multiple-of-5-in-the-sum/) | 쉬움 |
| [Trail 2 / 함수 / 값을 반환하는 함수](https://www.codetree.ai/trail-info/novice-mid/) | [[Concept]함수를 이용한 369 게임](https://www.codetree.ai/trails/complete/curated-cards/intro-369-games-using-functions/) | 보통 |
| [Trail 2 / 함수 / 값을 반환하는 함수](https://www.codetree.ai/trail-info/novice-mid/) | [[Challenge]출력결과 14](https://www.codetree.ai/trails/complete/curated-cards/challenge-reading-k201534/) | 쉬움 |
| [Trail 2 / 함수 / 값을 반환하는 함수](https://www.codetree.ai/trail-info/novice-mid/) | [[Challenge]출력결과 46](https://www.codetree.ai/trails/complete/curated-cards/challenge-reading-k201720/) | 쉬움 |
| [Trail 2 / 함수 / 값을 반환하는 함수](https://www.codetree.ai/trail-info/novice-mid/) | [[Challenge]출력결과 51](https://www.codetree.ai/trails/complete/curated-cards/challenge-reading-k201727/) | 보통 |
| [Trail 2 / 함수 / 값을 반환하는 함수](https://www.codetree.ai/trail-info/novice-mid/) | [[Challenge]출력결과 83](https://www.codetree.ai/trails/complete/curated-cards/challenge-reading-k201840/) | 쉬움 |

---------------------------------------

# 정수의 최솟값

## 문제 설명

세 정수 $a$와 $b$와 $c$가 주어지면 최소값을 출력하는 함수를 써서 풀랍니다.

## 풀이

최소값, 최댓값을 찾는 알고리즘은 대부분 다음과 같이 씁니다.

> <br>
> 
> 1. 정수든 실수든 해당 자료형이 가질 수 있는 최댓값, 최소값을 담는 변수 하나를 만듭니다.
> 2. 최소값을 찾고자 하면 최소값을 담을 변수에 해당 자료형이 갖는 최대값(제일 큰 값)을 할당
> 3. 최대값을 찾고자 하면 최대값을 담을 변수에 해당 자료형이 갖는 최소값(제일 작은 값)을 할당
> 4. 찾고자 하는 배열이든 뭐든을 전부 비교하며:
> 5. 최소값을 찾고자 하면 최소값으로 지정한 변수보다 더 작은 값이 있으면 최소값 변수를 그 더 작은 값으로 갱신합니다.
> 6. 최대값을 찾고자 하면 최대값으로 지정한 변수보다 더 큰 값이 있으면 최대값 변수를 그 더 큰 값으로 갱신합니다.
> <br>

```cpp

#include <climits>

// 최솟값
int min = INT_MAX;
int arr[100];

for (int i = 0; i < 100; i++) {
    if (arr[i] < min) {
        min = arr[i];
    }
}

// 최댓값
int max = INT_MIN;
int arr[100];

for (int i = 0; i < 100; i++) {
    if (max < arr[i]) {
        max = arr[i];
    }
}

```

하지만 이 상황은 주어진 값들 중에서 찾는 문제이니 굳이 자료형의 최댓값까지 불러와서 쓸 필요가 없습니다. 주어진 값들 중 아무 거나 하나 변수에 담고 주어진 값들을 순회하면서 값들을 갱신하면 되기 때문입니다. 코드는 다음과 같습니다.

## 코드

```cpp

#include <iostream>

using namespace std;

int a, b, c;

int min(int a, int b, int c) {
    int m = a;
    if (b < m)
        m = b;
    if (c < m)
        m = c;

    return m;
}

int main() {
    cin >> a >> b >> c;

    cout << min(a, b, c);

    return 0;
}

```

---------------------------------------

# 짝수이면서 합이 5의 배수인 수

## 문제 설명

2자리 숫자 $n$이 주어지고, $n$이 짝수이면서 각 자릿수 합이 5의 배수이면 `Yes`를 아니면 `No`를 출력하는 문제입니다.

## 풀이

저는 뭔가 여태까지 자릿수를 다루는 상황에서 문자열로 해결해버리곤 했는데, 정수면 그냥 다음과 같이 하는 게 더 빠르고 속편하다는 걸 알았습니다.

1. 자릿수 크기만큼의 배열을 만듭니다. (논리적으로 각 자릿수의 값을 개별로 다루고 싶다는 건 자릿수를 하나하나 저장하겠다는 거니 자릿수 개수(크기)만큼의 변수가 필요하겠지요.)
2. 해당 자릿수 개수만큼 반복문(`while`)으로 해당 숫자를 모듈러 10(`% 10`)을 한 값을 자릿수 배열에 담습니다.
3. 담은 후 해당 숫자를 10으로 나눈 후 다시 해당 숫자를 담은 변수에 할당합니다.
4. 이를 반복하여 자릿수 값들을 얻습니다.

코드는 아래와 같습니다.

```cpp

// C++(C도 마찬가지)에서 배열을 반환할 수는 없습니다. 그러니 전역에 하나 멋드러지게 만들어줍니다.
int digits[9];

int extract(int x) {
    int i = 0;
    while (x > 0) {
        digits[i++] = x % 10;
        x /= 10;
    }
}

// C++ 문법 요소인 증감연산자를 배제하고 풀어쓰면 다음과 같이도 쓸 수 있습니다.
int extract_easy(int x) {
    int i = 0;
    while (x > 0) {
        digits[i] = x % 10;
        x /= 10;
        i++;
    }
}

```

입력으로 받든 주어지든 구할 수의 자릿수 크기를 미리 알 수 있으면 `for`로 해도 되지만, 그냥 `while`로 하면 속편합니다. 조건식은 `x > 0`으로 하면 되는데, `x`를 10으로 계속 나누다가, C/C++은 정수를 정수로 나누면 정수가 되니 끝내 `x`는 반복이 종료되기 전의 phase(순서, 차례)에서 0이 됩니다. 37로 예시를 들어보면:

1. 37 → 7 저장, 나누기 10, 결과 3
2. 3 → 3 저장, 나누기 10, 결과 0 (`3 / 10 == 0.3` 이나 소수부 버림)
3. 0 → 루프 탈출

## 코드

```cpp

#include <iostream>

using namespace std;

int n;

string isNumMeets(int n) {
    int dig10 = n / 10;
    int dig1 = n % 10;

    if (n % 2 == 0)
        if ((dig1 + dig10) % 5 == 0)
            return "Yes";
    
    return "No";
}

int main() {
    cin >> n;

    cout << isNumMeets(n);

    return 0;
}

```

---------------------------------------

# 함수를 이용한 369게임

## 문제 설명

정수 $A$와 $B$가 주어지면 $A$이상 $B$이하의 수들 중 $3, 6, 9$가 들어가있거나, 그 수 자체가 3의 배수인 수들의 개수를 세는 함수로 풉니다.

## 풀이

만족할 수 있는(OR) 조건이 두 개입니다.

1. 3, 6, 9 중 하나가 들어가있으면 OK
2. 3의 배수이면 OK

"3의 배수인가"라는 조건은 모듈러 3(`% 3`)으로 비교적 쉽게 표현되니 이걸 main쪽으로 넣고, 자릿수를 확인해야하는 1번 조건은 따로 bool을 반환하는 함수로 조건의 만족을 판단합니다.

```cpp

#include <iostream>

using namespace std;

int a, b;

bool is369Inside(int n) {
    int num = n;
    while (num > 0) {
        if ((num % 10) == 3 || (num % 10) == 6 || (num % 10) == 9)
            return true;
        num /= 10;
    }
    return false;
}

bool isNumberMeets(int n) {
    return (n % 3 == 0) || is369Inside(n);
}

int main() {
    cin >> a >> b;

    int cnt = 0;
    for (int i = a; i <= b; i++) {
        if (isNumberMeets(i))
            cnt++;
    }

    cout << cnt;

    return 0;
}

```

### 코드플러스

{% include callout.html title="argument로 받은 원본 보호" type="note" content="argument로 받은 n을 수정하는 것보다 해당 값의 복사본을 담아서 그걸 조작하며 그 값이 조건을 만족하는 값인지 검사하도록 num = n을 해줬습니다." %}

---------------------------------------

# 출력결과 14

## 문제 설명

```cpp

int f(int x) {
    return (x / 2.5) * 3;
}

```

에서, f(12)의 출력 결과가 뭐냐고 합니다. 5지선다입니다.

## 풀이

식 결과가 14.4라서 답은 14입니다.

---------------------------------------

# 출력결과 46

## 문제 설명

```cpp

int f(int x) { 
    int cnt = 0;
    while (x % 2 == 0) { 
        x /= 2;
        cnt++; 
    }
    return cnt; 
}

```

에서, f(48)의 출력 결과가 뭐냐고 합니다. 5지선다입니다.

## 풀이

보통 코드는 코드가 먼저 있기보다 현실의 현상이 먼저 있고 그걸 코드로 표현하는 경우가 태반이죠. 이 문제는 x가 홀수가 될 때까지 2로 나눈 횟수를 세네요.  

정답은 3이 될 때까지 나누니까 네 번 나누니 4입니다.

---------------------------------------

# 출력결과 14

## 문제 설명

```cpp

int Lee(int x) 
{
    int last = 10; 
    while (x){
        if (x % 10 > last) return 0; 
        last = x % 10;
        x /= 10;
    }
    return 1; 
}


```

에서, Lee(654321) + Lee(123345) + Lee(442211) + Lee(202104)의 값이 뭐냐고 합니다. 5지선다입니다.

## 풀이

아까의 말을 빌려 어떤 현상인지 파악해보면, 각 자릿수를 일단 비교합니다. 처음에 last라는 값이 10으로 할당되는데, 이는 첫 자릿수를 무조건 last에 대입할 수 있도록 하기 위한 장치일 뿐이고, 안에서 하는 일은 while의 현재 phase의 자릿수가 last보다 큰 순간 바로 0을 리턴하게 되고, 그게 아니면 쭉쭉 x가 0이 될 때까지 나눕니다. 그리고 while이 끝나면 1을 리턴하게 되고, while이 끝났다는 말은 모든 자릿수의 숫자가 현재 phase의 자릿수보다 작음을 말합니다. 다시 말해 모든 자릿수의 값이 이전 자릿수의 값보다 작은 값(0123456789 같은 거)이면 1을 리턴한다는 겁니다.  

결론: 최종적으로 모든 자릿수가 오름차순으로 정렬돼있으면 1, 모든 자릿수가 내림차순 혹은 부분적으로라도 내림차순이 존재하면 0입니다.  
정답:
- Lee(654321) = 0
- Lee(123345) = 1
- Lee(442211) = 0
- Lee(202104) = 0
- 0 + 1 + 0 + 0 = 1  

정답은 1입니다.

---------------------------------------

# 출력결과 83

## 문제 설명

```cpp

int f(int n) {  
    int i, j, s;  
    s = 0;  
    for (i = 0; i < n; i += 2)    
        for (j = 0; j < i; j += 2)      
            s += i + j;    
    return s;
}

```

에서, f(10)의 값이 뭐냐고 합니다. 5지선다입니다.

## 풀이

i는 0, 2, 4, 6, 8이 됩니다.  
j는:
1. i가 0일 때는 실행되지 않습니다.
2. i가 2일 때는 j는 0이 됩니다: s = 2 + 0
3. i가 4일 때는 j는 0, 2가 됩니다: s += 4 + 0; s += 4 + 2;
4. i가 6일 때는 j는 0, 2, 4가 됩니다: s += 6 + 0; s += 6 + 2; s += 6 + 4;
5. i가 8일 때는 j는 0, 2, 4, 6이 됩니다: s += 8 + 0; s += 8 + 2; s += 8 + 4; s += 8 + 6;

정답은 s = 2 + 4 + 4 + 2 + 6 + 6 + 2 + 6 + 4 + 8 + 8 + 2 + 8 + 4 + 8 + 6 = 80입니다.

---------------------------------------

# Referernce

- [Microsoft - C/C++ 정수 제한](https://learn.microsoft.com/ko-kr/cpp/c-language/cpp-integer-limits?view=msvc-160)
