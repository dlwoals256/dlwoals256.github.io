---
title: 코드트리 문제풀이[옛날에 푼 거 정리(14)]
date: 2025-08-11 12:11:50 +0900
categories: [Problem Solving]
tags: [코딩테스트, 코드트리]
description: 1이 되는 순간까지, Factorial, 각 자리 숫자의 제곱
toc: false
comments: false
math: true
mermaid: false
---

# 문제

| 유형 | 문제 링크 | 난이도 |
| --- | --- | --- |
| [Trail 2 / 재귀함수 / 값을 반환하는 재귀함수](https://www.codetree.ai/trail-info/novice-mid/) | [[Concept]1이 되는 순간까지](https://www.codetree.ai/trails/complete/curated-cards/intro-until-the-moment-I-reach-one/) | 쉬움 |
| [Trail 2 / 재귀함수 / 값을 반환하는 재귀함수](https://www.codetree.ai/trail-info/novice-mid/) | [[Challenge]Factorial](https://www.codetree.ai/trails/complete/curated-cards/challenge-factorial/) | 쉬움 |
| [Trail 2 / 재귀함수 / 값을 반환하는 재귀함수](https://www.codetree.ai/trail-info/novice-mid/) | [[Concept]각 자리 숫자의 제곱](https://www.codetree.ai/trails/complete/curated-cards/intro-square-of-each-digit/) | 쉬움 |

---------------------------------------

# 개념 설명

재귀함수가 수행하는 일이 점화식으로 표현이 가능할 때, 그 점화식을 그대로 재귀함수의 리턴으로 줌으로써 알고리즘의 표현이 가능합니다. 예를 들어 피보나치 수열입니다.

```cpp

int fibo(int n) {
    if (n == 0) return 0;
    if (n == 1 || n == 2) return 1;
    return fibo(n - 1) + fibo(n - 2);
}

```

위와 같이 함으로써 $n$ 번째 피보나치 수열의 값을 얻을 수 있습니다. 즉, `fibo(n - 1)` 부분이 표현한 그대로 $n - 1$ 번째 피보나치 수열의 값이 되며, `fibo(n - 2)` 부분도 마찬가지입니다.

---------------------------------------

# 1이 되는 순간까지

## 문제 설명

$N$ 이 주어지고 이 $N$ 이 짝수이면 $2$ 로 나누고 홀수이면 $3$ 으로 나눈 몫을 취하는 걸 반복하다가 $1$ 이 되면 여태 진행한 작업의 횟수를 구하는 프로그램을 짭니다.

## 풀이

재귀함수가 수행하는 일을 점화식으로 표현이 가능할 때 그를 그대로 코드로 적으면 점화식의 값을 얻게 됩니다. 여기서, 점화식 대로 연산한 횟수를 구하는 것이므로 점화식 + 1을 해주어 횟수를 구할 수 있습니다. 저는 이걸 이해하지 못하여 `cnt`라는 파라미터를 따로 두었었는데, 다른 풀이를 보고 `task2` 함수처럼 할 수 있다는 걸 이해했습니다. 재귀 탈출 조건을 만족 시 0을 리턴하기 때문에, 오로지 재귀 호출 식 뒤의 `+1`만 유효한 값이 되어 횟수를 올바르게 셀 수 있게 됩니다.

## 코드

```cpp

#include <iostream>

using namespace std;

int N;

// 처음 풀이
int task(int n, int cnt) {
    if (n <= 1) return cnt;
    int recur = n;
    if (n % 2 == 0) {
        return task(recur / 2, cnt + 1);
    } else {
        return task(recur / 3, cnt + 1);
    }
}

// 계산된 값이 필요한 게 아니라서 계산의 결과를 파라미터로 전달하지 않는다.
int task2(int n) {
    if (n <= 1) return 0;
    if (n % 2 == 0) {
        return task2(n / 2) + 1;
    } else {
        return task2(n / 3) + 1;
    }
}

int main() {
    cin >> N;

    cout << task2(N);

    return 0;
}

```

---------------------------------------

# Factorial

## 문제 설명

$N$ 이 주어지면 $N!$ 을 구합니다.

## 코드

```cpp

#include <iostream>

using namespace std;

int N;

int fac(int n) {
    if (n <= 1) return 1;
    return fac(n - 1) * n;
}

int main() {
    cin >> N;

    cout << fac(N);

    return 0;
}

```

---------------------------------------

# 각 자리 숫자의 제곱

## 문제 설명

8자리 이하의 정수 $N$ 이 주어지면 각 자리 숫자의 제곱의 합을 구합니다.

## 풀이

이번에는 재귀 탈출 조건으로 0이 아닌 점화식에서 표현하는 제곱을 그대로 전달합니다. 한 자릿수 수 $n$ 에 대한 제곱은 다음과 같이 쓸 수 있습니다: $n^2 = n \times n$ 그리고 어떤 자릿수를 가지는 수 $n$ 에 대한 제곱은 다음과 같이 쓸 수 있습니다: $(n \mod 10)^2$ 이를 모든 자릿수 수에 대해 수행해야 하는데, $(n \mod 10)^2 = f(n)$ 이라고 하면, 어떤 자릿수 수 $n$ 의 10의 자리 수에 대한 제곱은 다음과 같이 쓸 수 있습니다: $f(n / 10)$ 이를 코드로 표현하면 아래와 같습니다.

## 코드

```cpp

#include <iostream>

using namespace std;

int N;

int square_sum(int n) {
    if (n < 10) return n * n;
    return square_sum(n / 10) + (n % 10) * (n % 10);
}

int main() {
    cin >> N;

    cout << square_sum(N);

    return 0;
}

```
