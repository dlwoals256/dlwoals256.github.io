---
title: 코드트리 문제풀이[옛날에 푼 거 정리(7)]
date: 2025-08-04 12:11:50 +0900
categories: [Problem Solving]
tags: [코딩테스트, 코드트리]
description: 2021년 날짜의 유무, 출력결과 67, 함수를 이용한 연속부분수열 여부 판단하기, 그 계절, 그 날
toc: false
comments: false
math: true
mermaid: false
---

# 문제

| 유형 | 문제 링크 | 난이도 |
| --- | --- | --- |
| [Trail 2 / 함수 / 값을 반환하는 함수](https://www.codetree.ai/trail-info/novice-mid/) | [[Challenge]2021년 날짜의 유무](https://www.codetree.ai/trails/complete/curated-cards/challenge-with-or-without-2021/) | 보통 |
| [Trail 2 / 함수 / 값을 반환하는 함수](https://www.codetree.ai/trail-info/novice-mid/) | [[Challenge]출력결과 67](https://www.codetree.ai/trails/complete/curated-cards/challenge-reading-k201821/) | 쉬움 |
| [Trail 2 / 함수 / 값을 반환하는 함수](https://www.codetree.ai/trail-info/novice-mid/) | [[Challenge]함수를 이용한 연속부분수열 여부 판단하기](https://www.codetree.ai/trails/complete/curated-cards/challenge-to-determine-whether-a-continuous-subsequence-is-made-using-a-function/) | 보통 |
| [Trail 2 / 함수 / 값을 반환하는 함수](https://www.codetree.ai/trail-info/novice-mid/) | [[Test]그 계절, 그 날](https://www.codetree.ai/trails/complete/curated-cards/test-that-season-that-day/) | 어려움 |


---------------------------------------

# 2021년 날짜의 유무

## 문제 설명

정수 $M$ 와 $D$ 가 주어지면 2021년 $M$ 월  $D$ 일이 존재하면 Yes, 아니면 No를 출력하면 되네요.

## 코드

```cpp

#include <iostream>

using namespace std;

int M, D;
bool calendar[13][32] = {};
const int month_last[13] = {
  0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31
};

void init_calendar() {
  for (int m = 1; m <= 12; m++) {
    for (int d = 1; d <= month_last[m]; d++) {
      calendar[m][d] = true;
    }
  }
}

bool is_date_valid(int m, int d) {
  if (m > 12 || m < 1) return false;
  if (d > 31 || d < 1) return false;
  return calendar[m][d];
}

int main() {
  cin >> M >> D;

  init_calendar();
  if (is_date_valid(M, D)) cout << "Yes";
  else cout << "No";

  return 0;
}

```

### 코드플러스

{% include callout.html title="캘린더 구현" type="note" content="캘린더는 구현하기 쉽지~ 하고 생각하다가 막상 문제 상황에 직면하니 버벅였습니다. 그냥 정확히 패턴을 구현하는 것(31일이 존재하는 월, 1-based indexing, 경계값 처리 등)을 외워두면 좋겠습니다." %}

---------------------------------------

# 출력결과 67

## 문제 설명

다음 코드의 출력 결과를 고르는 5지선다입니다.

## 코드

```cpp

int f(int n) {  
    if (n < 2)    
        return 0;  
    for(int d = n - 1; d > 1; d--) {    
        if (n % d == 0)      
            return 0;  
    }  
    return 1;
}
int main() {  
    cout << f(1) << " ";
    cout << f(11) << " ";
    cout << f(21) << " ";
    cout << f(31) << " ";
    return 0;
}

```

## 풀이

`n`으로 받는 숫자가 `n`보다 작은 어떤 수로 나누어떨어지면 `0`, 아니면 `1`을 출력하는 게 `f`의 역할입니다. 즉, 소수인지 보는 것입니다. 이때, `0`과 `1`은 소수가 아니므로 `0`입니다.  

정답은 `0 1 0 1` 입니다.

---------------------------------------

# 함수를 이용한 연속부분수열 여부 판단하기

## 문제 설명

$n_1$ 개의 원소로 이루어진 수열 $A$ 의 정보와 $n_2$ 개의 원소로 이루어진 수열 $B$ 의 정보가 주어질 때 수열 $B$ 가 수열 $A$ 의 연속부분수열인지 판단하는 함수를 씁니다. 연속부분수열은 다음과 같은 것을 가리킵니다:  

> 수열 $B$ 가 수열 $A$ 의 원소들을 연속하게 뽑았을 때 나올 수 있는 수열일 때 수열 $B$ 는 수열 $A$ 의 연속부분수열이라고 부릅니다.

예를 들어 다음과 같습니다:  

수열 $A$ : $[1, 2, 7, 8]$
수열 $B$ : $[7, 2]$

## 풀이

수열 $A$의 어떤 원소 $x_i$ 가 수열 $B$ 의 첫 번째 원소와 같으면 검사를 시작합니다. 그리고 도중에 하나라도 다른 값이 있으면 탈출하고 검사를 하는 루프의 인덱스 `j`가 수열 $B$ 의 크기(B의 크기 - 1)와 같아지면 모두 검사를 했다는 뜻이 되므로 flag 변수를 `true`로 바꾸고 반복을 종료합니다.

## 코드

```cpp

#include <iostream>

using namespace std;

int n1, n2;
int a[100], b[100];

bool is_sequence(int* x, int* y) {
    int res = false;
    for (int i = 0; i < n1; i++) {
        if (x[i] == y[0]) {
            for (int j = 0; j < n2; j++) {
                if (x[i+j] != y[j]) break;
                if (j == n2 - 1) res = true;
            }
        }
    }

    return res;
}

int main() {
    cin >> n1 >> n2;

    for (int i = 0; i < n1; i++) cin >> a[i];

    for (int i = 0; i < n2; i++) cin >> b[i];

    if (n1 >= n2 && is_sequence(a, b)) {
        cout << "Yes";
    } else {
        cout << "No";
    }
    
    return 0;
}

```

---------------------------------------

# 그 계절, 그 날

## 문제 설명

어떤 연도, 월, 일이 차례로 세 개의 정수 $Y, M, D$ 로 주어질 때, $Y$ 해에 $M$ 월 $D$ 일이 존재하면 어떤 계절인지 출력하고, 존재하지 않으면 `-1`을 출력하는 함수를 짭니다.

## 풀이

캘린더 구현과 윤년 판별을 합친 문제입니다. 어찌보면 이게 실제 현실을 반영하는 그레고리력 캘린더의 구현이 되겠네요.

## 코드

```cpp

#include <iostream>

using namespace std;

int Y, M, D;

bool is_leap(int y) {
    bool res = false;
    if (y % 4 == 0) {
        res = true;
        if (y % 100 == 0) {
            res = false;
            if (y % 400 == 0) {
                res = true;
            };
        }
    }

    return res;
}

string season(int m) {
    if (m >= 3 && m <= 5) {
        return "Spring";
    } else if (m >= 6 && m <= 8) {
        return "Summer";
    } else if (m >= 9 && m <= 11) {
        return "Fall";
    } else {
        // m은 season 함수가 실행되었다면 반드시 1 ~ 12 사이이므로 else로 처리할 수 있다.
        return "Winter";
    }
}

bool calender[13][32];
const int lst_day[13] = {
    0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31
};

int main() {
    cin >> Y >> M >> D;

    for (int i = 1; i < 13; i++) {
        for (int j = 1; j <= lst_day[i]; j++) {
            calender[i][j] = true;
        }
        if (i == 2 && is_leap(Y)) {
            calender[i][29] = true;
        }
    }

    if (calender[M][D]) {
        cout << season(M);
    } else {
        cout << -1;
    }

    return 0;
}

```


