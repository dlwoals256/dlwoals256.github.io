---
title: 코드트리 문제풀이[옛날에 푼 거 정리(2)]
date: 2025-07-29 12:11:50 +0900
categories: [Problem Solving]
tags: [코딩테스트, 코드트리]
description: 최대공약수 구하기, 출력결과 20, 출력결과 72, 1부터 특정 수까지의 합, 최소공배수 구하기
toc: false
comments: false
math: true
mermaid: false
---

# 문제

| 유형 | 문제 링크 | 난이도 |
| --- | --- | --- |
| [Trail 2 / 함수 / 값을 반환하지 않는 함수](https://www.codetree.ai/trail-info/novice-mid/) | [[Challenge]최대공약수 구하기](https://www.codetree.ai/trails/complete/curated-cards/challenge-find-the-greatest-common-divisor/) | 쉬움 |
| [Trail 2 / 함수 / 값을 반환하지 않는 함수](https://www.codetree.ai/trail-info/novice-mid/) | [[Challenge]출력결과 20](https://www.codetree.ai/trails/complete/curated-cards/challenge-reading-k201544/) | 어려움 |
| [Trail 2 / 함수 / 값을 반환하지 않는 함수](https://www.codetree.ai/trail-info/novice-mid/) | [[Challenge]출력결과 72](https://www.codetree.ai/trails/complete/curated-cards/challenge-reading-k201827/) | 쉬움 |
| [Trail 2 / 함수 / 값을 반환하는 함수](https://www.codetree.ai/trail-info/novice-mid/) | [[Concept]1부터 특정 수까지의 합](https://www.codetree.ai/trails/complete/curated-cards/intro-sum-from-1-to-a-certain-number/) | 쉬움 |
| [Trail 2 / 함수 / 값을 반환하지 않는 함수](https://www.codetree.ai/trail-info/novice-mid/) | [[Test]최소공배수 구하기](https://www.codetree.ai/trails/complete/curated-cards/test-find-the-least-common-multiple/) | 쉬움 |

---------------------------------------

# 최대공약수 구하기

## 문제 설명

$n$과 $m$이 주어지면 $n$과 $m$의 최대공약수를 출력하는 함수를 써서 풀랍니다.

## 풀이

GCD 알고리즘(유클리드 호제법, GCD, Greatest Common Divisor)이라는 것이 있습니다. 간단히 설명하자면, 두 정수 $a$와 $b$, 그리고 $a$를 $b$로 나눈 나머지를 $r$이라고 하고 $a$와 $b$의 최대공약수를 $(a, b)$라고 하면 다음과 같은 식이 성립합니다.

\
$$
(a, b) = (b, r)
$$

예를 들어 1071과 1029를 예시로 들면 다음과 같습니다:

\
$$
(1071, 1029) = (1029, 42) = (42, 21) = (21, 0) = 21
$$

즉, 위 식을 a와 b에 대해 계속 적용하다가, b가 0이 되면 0인 순간의 a가 초기의 a와 b에 대한 최대공약수가 되는 것입니다.

## 코드

```cpp

#include <iostream>

using namespace std;

int n, m;

int gcd(int a, int b) {
    if (b == 0) {
        return a;
    }

    return gcd(b, a % b);
}

int main() {
    cin >> n >> m;

    cout << gcd(n, m);

    return 0;
}

```

---------------------------------------

# 출력결과 20

## 문제 설명

다음 코드의 출력 결과를 고르는 5지선다 문제입니다.

```cpp

int a[3][4] = {
    {2, 0, 1, 5},
    {0, 4, 1, 1},
    {1, 4, 0, 0}
};
void f(int b) {
    int i;
    for(i = 0; i < 4; i++) {
        a[b][i] = a[(b + 1) % 3][(i + 1) % 4];
    }
}
int main() {
    int i, tot = 0;
    f(1);
    f(2);
    f(0);
    for(i = 0; i < 3; i++) {
        tot = tot + a[i][(i + 1) % 4];
    }
    cout << tot;
    return 0;
}

```

## 풀이

일단 `main`에서, `f(1) --> f(2) --> f(0)`의 순서로 호출하고 있습니다. `f`는 배열의 원소를 조작하는 함수이고, 이후 `tot`라는 결과를 반복문으로 만들어서 출력합니다.  

이 문제는 `f`내부의 반복문 인덱스로 무슨 짓을 하고 있는지 파악하는 게 핵심입니다. `f`의 인자로 전달하는 `b`는 **행 번호**를 가리킵니다. 그리고 사실 뒤에 있는 모듈러 연산자(%)는 **무시해도 됩니다**.  

여기서 모듈러 연산자의 역할은 단순히 **안전**을 위한 것입니다. 무슨 말이냐면, 모듈러 연산자의 결과는 예를 들어, `x % 10`의 결과는 `x`가 뭐가 되든 `0~9`까지로 제한됩니다. 그 말인 즉슨 반복문을 돌다가 인덱스가 마지막 인덱스로부터 벗어나면 **다시 처음 인덱스로 돌아가게 만드는** 게 모듈러 연산자의 역할입니다.  

그렇다면 모듈러 연산자를 걷어내고 보면 이해하기 쉬워집니다.  

```cpp

void f(int b) {
    int i;
    for(i = 0; i < 4; i++) {
        a[b][i] = a[(b + 1)][(i + 1)];
    }
}

```

라는 코드는 조금 더 직관적으로, **현재 b행 i열의 원소를 b+1행 i+1열로 옮겨라** 라는 것을 파악할 수 있게 됩니다. 조금 더 나아가서 다시 표현해보면, **`b` 행의 모든 원소를 오른쪽 대각선 아래로 내려라** 로 표현할 수 있겠습니다.

이후 `tot`의 값을 계산하고 출력하면 됩니다. (i, i+1)의 값을 세 번 더하면 됩니다. 즉, (0, 1), (1, 2), (2, 3)을 더하면 되겠지요.

---------------------------------------

# 출력결과 72

## 문제 설명

다음 코드에서 문자열 `"Lee"`를 출력하는 경우는 `f(x, y)`에 대해 뭘 넣어야 하는지를 고르는 5지선다 문제입니다.

```cpp

void f(int a, int b) {  
    int c, d = 0, e = 17;  
    c = a + 5;  
    if (a + b < c) {     
        if (a == b) {      
            cout << "Lee";
        }     
    }
}

```

## 풀이

`d`랑 `e`가 있는데, 문제에서 요구하는 상황과는 전혀 연관되어 있지 않으니 무시합니다. 함정 같은 거라고 보면 됩니다. 그렇게 되면 `c`는 `a + 5`랑 같은 값이니 결국 `a + b < a + 5`가 되겠고, `b < 5`인 선지만 골라주면 되겠습니다.  

정답은 `f(3, 3)`이었습니다.

---------------------------------------

# 1부터 특정 수까지의 합

## 문제 설명

정수 $N$이 주어지면, $1$부터 전달받은 수까지의 합을 $10$으로 나눈 값을 반환하는 함수의 값을 출력하라네요.

## 코드

```cpp

#include <iostream>

using namespace std;

int N;

int divSum(int n) {
    int sum = 0;
    for (int i = 1; i <= n; i++) {
        sum += i;
    }

    return sum / 10;
}

int main() {
    cin >> N;

    cout << divSum(N);

    return 0;
}

```

---------------------------------------

# 최소공배수 구하기

## 문제 설명

$n, m$이 주어지면, $n$과 $m$의 최소공배수를 출력합니다.

## 풀이

상기했던 GCD 알고리즘을 빌려옵니다. GCD 알고리즘으로 구한 $n$과 $m$의 최대공약수를 $\text{gcd} (n, m)$ 이라고 하면 최소공배수 LCM(Least Common Multiple)은 다음과 같습니다.  

\
$$
\text{LCM} (n, m) = \frac{n \times m}{\text{gcd} (n, m)}
$$

이걸 코드로 표현하면 다음과 같습니다.

## 코드

```cpp

#include <iostream>

using namespace std;

int n, m;

int gcd(int x, int y) {
    if (y == 0) {
        return x;
    }

    int r = x % y;

    return gcd(y, r);
}

int main() {
    cin >> n >> m;

    cout << n*m / gcd(n, m);

    return 0;
}

```

---------------------------------------

# Reference
- [Wikipidia: Euclidian algorithm](https://ko.wikipedia.org/wiki/%EC%9C%A0%ED%81%B4%EB%A6%AC%EB%93%9C_%ED%98%B8%EC%A0%9C%EB%B2%95)