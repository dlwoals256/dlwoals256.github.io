---
title: 코드트리 문제풀이[옛날에 푼 거 정리(5)]
date: 2025-08-02 12:11:50 +0900
categories: [Problem Solving]
tags: [코딩테스트, 코드트리]
description: 두 수의 거듭제곱, 사칙연산 함수, 출력결과 56, 출력결과 22, 출력결과 66
toc: false
comments: false
math: true
mermaid: false
---

# 문제

| 유형 | 문제 링크 | 난이도 |
| --- | --- | --- |
| [Trail 2 / 함수 / 값을 반환하는 함수](https://www.codetree.ai/trail-info/novice-mid/) | [[Challenge]두 수의 거듭제곱](https://www.codetree.ai/trails/complete/curated-cards/challenge-two-numbers-of-squares/) | 쉬움 |
| [Trail 2 / 함수 / 값을 반환하는 함수](https://www.codetree.ai/trail-info/novice-mid/) | [[Challenge]사칙연산 함수](https://www.codetree.ai/trails/complete/curated-cards/challenge-quadratic-operations-function/) | 보통 |
| [Trail 2 / 함수 / 값을 반환하는 함수](https://www.codetree.ai/trail-info/novice-mid/) | [[Challenge]출력결과 56](https://www.codetree.ai/trails/complete/curated-cards/challenge-reading-k201732/) | 보통 |
| [Trail 2 / 함수 / 값을 반환하는 함수](https://www.codetree.ai/trail-info/novice-mid/) | [[Challenge]출력결과 22](https://www.codetree.ai/trails/complete/curated-cards/challenge-reading-k201547/) | 쉬움 |
| [Trail 2 / 함수 / 값을 반환하는 함수](https://www.codetree.ai/trail-info/novice-mid/) | [[Challenge]출력결과 66](https://www.codetree.ai/trails/complete/curated-cards/challenge-reading-k201820/) | 쉬움 |

---------------------------------------

# 두 수의 거듭제곱

## 문제 설명

정수 $a$와 $b$가 주어지면, $a^b$를 반환하는 함수를 짭니다.

## 코드

```cpp

#include <iostream>

using namespace std;

int a, b;

int pow(int a, int b) {
    int res = 1;
    for (int i = 0; i < b; i++) {
        res *= a;
    }
    return res;
}

int main() {
    cin >> a >> b;

    cout << pow(a, b);

    return 0;
}

```

---------------------------------------

# 사칙연산 함수

## 문제 설명

주어지는 값으로 사칙연산을 하고 예외처리도 해봅니다.

## 코드

```cpp

#include <iostream>

using namespace std;

int a;
int c;
char o;

int add(int x, int y) {
    return x + y;
}

int sub(int x, int y) {
    return x - y;
}

int mul(int x, int y) {
    return x * y;
}

int div_(int x, int y) {
    return x / y;
}

int main() {
    cin >> a >> o >> c;

    if (o == '+') {
        cout << a << ' ' << o << ' ' << c << " = " << add(a, c);
    } else if (o == '-') {
        cout << a << ' ' << o << ' ' << c << " = " << sub(a, c);
    } else if (o == '*') {
        cout << a << ' ' << o << ' ' << c << " = " << mul(a, c);
    } else if (o == '/') {
        cout << a << ' ' << o << ' ' << c << " = " << div_(a, c);
    } else {
        cout << "False";
    }

    return 0;
}

```

---------------------------------------

# 출력결과 56

## 문제 설명

```cpp

int f(int n){
    int a[15] = {1, 1, 2, 3, 2,   1, 4, 1, 1, 1,   2, 4, 2, 3, 4};
    int idx = 0;
    while(n < 15){ 
        n += a[n];
        idx++; 
    }
    return idx;
}


```

에서, 리턴이 5가 되는 양의 정수 n이 몇 개냐고 합니다. 5지선다입니다.

## 풀이

일단, `idx`가 아니라 `n`이 반복의 조건으로 걸려있습니다. `idx`는 0부터 반복 횟수 동안 1씩 증가합니다. `n`은 선형으로 증가하는 게 아니라 배열 원소 값만큼 증가합니다. 그리고 `idx`를 리턴하는데, 결국 이건 **몇 번 했냐?**를 묻는 문제이네요. 그럼 문제를 다시 말하자면, 5번 반복하는 `n`의 출발점은 몇 개냐?라고 할 수 있겠습니다.  

1. `n = 1`:
    1. `1 += a[1] → 1 += 1 == 2 → idx == 1`
    2. `2 += a[2] → 2 += 2 == 4 → idx == 2`
    3. `4 += a[4] → 4 += 2 == 6 → idx == 3`
    4. `6 += a[6] → 6 += 4 == 10 → idx == 4`
    5. `10 += a[10] → 10 += 2 == 12 → idx == 5`
    6. `12 += a[12] → 12 += 2 == 14 → idx == 6`
    7. `14 += a[14] → 14 += 4 == 18 → idx == 7`
2. `n = 2`:
    1. `2 += a[2] → 2 += 2 == 4 → idx == 1`
    2. `4 += a[4] → 4 += 2 == 6 → idx == 2`
    3. `6 += a[6] → 6 += 4 == 10 → idx == 3`
    4. `10 += a[10] → 10 += 2 == 12 → idx == 4`
    5. `12 += a[12] → 12 += 2 == 14 → idx == 5`
    6. `14 += a[14] → 14 += 4 == 18 → idx == 6`
3. `n = 3`
    1. `3 += a[3] → 3 += 3 == 6 → idx == 1`
    2. `6 += a[6] → 6 += 4 == 10 → idx == 2`
    3. `10 += a[10] → 10 += 2 == 12 → idx == 3`
    4. `12 += a[12] → 12 += 2 == 14 → idx == 4`
    5. `14 += a[14] → 14 += 4 == 18 → idx == 5`
4. `n = 4`
    1. `4 += a[4] → 4 += 2 == 6 → idx == 1`
    2. `6 += a[6] → 6 += 4 == 10 → idx == 2`
    3. `10 += a[10] → 10 += 2 == 12 → idx == 3`
    4. `12 += a[12] → 12 += 2 == 14 → idx == 4`
    5. `14 += a[14] → 14 += 4 == 18 → idx == 5`
5. `n = 5`
    1. `5 += a[5] → 5 += 1 == 6 → idx == 1`
    2. `6 += a[6] → 6 += 4 == 10 → idx == 2`
    3. `10 += a[10] → 10 += 2 == 12 → idx == 3`
    4. `12 += a[12] → 12 += 2 == 14 → idx == 4`
    5. `14 += a[14] → 14 += 4 == 18 → idx == 5`
6. `n = 6`
    1. `6 += a[6] → 6 += 4 == 10 → idx == 1`
    2. `10 += a[10] → 10 += 2 == 12 → idx == 2`
    3. `12 += a[12] → 12 += 2 == 14 → idx == 3`
    4. `14 += a[14] → 14 += 4 == 18 → idx == 4`
7. `n = 7`
    1. `7 += a[7] → 7 += 1 == 8 → idx == 1`
    2. `8 += a[8] → 8 += 1 == 9 → idx == 2`
    3. `9 += a[9] → 9 += 1 == 10 → idx == 3`
    4. `10 += a[10] → 10 += 2 == 12 → idx == 4`
    5. `12 += a[12] → 12 += 2 == 14 → idx == 5`
    6. `14 += a[14] → 14 += 4 == 18 → idx == 6`
8. `n = 8`
    1. `8 += a[8] → 8 += 1 == 9 → idx == 1`
    2. `9 += a[9] → 9 += 1 == 10 → idx == 2`
    3. `10 += a[10] → 10 += 2 == 12 → idx == 3`
    4. `12 += a[12] → 12 += 2 == 14 → idx == 4`
    5. `14 += a[14] → 14 += 4 == 18 → idx == 5`
9. `n = 9`
    1. `9 += a[9] → 9 += 1 == 10 → idx == 1`
    2. `10 += a[10] → 10 += 2 == 12 → idx == 2`
    3. `12 += a[12] → 12 += 2 == 14 → idx == 3`
    4. `14 += a[14] → 14 += 4 == 18 → idx == 4`
10. `n = 10`
    1. `10 += a[10] → 10 += 2 == 12 → idx == 1`
    2. `12 += a[12] → 12 += 2 == 14 → idx == 2`
    3. `14 += a[14] → 14 += 4 == 18 → idx == 3`
11. `n = 11`
    1. `11 += a[11] → 11 += 4 == 15 → idx == 1`
12. `n = 12`
    1. `12 += a[12] → 12 += 2 == 14 → idx == 1`
    2. `14 += a[14] → 14 += 4 == 18 → idx == 2`
13. `n = 13`
    1. `13 += a[13] → 13 += 3 == 16 → idx == 1`
14. `n = 14`
    1. `14 += a[14] → 14 += 4 == 18 → idx == 1`

`n`은 3, 4, 5, 8로 총 4개이네요. 이 문제는 이런식으로 전부 넣어보는 수 밖에 없는데, 일단 1을 먼저 해보면 그 이후는 복사 붙여넣기입니다. 왜냐하면 예를 들어 1을 넣어보면 바로 다음에 `n`이 2가 되는데, 이는 `n = 2`인 경우랑 같은 경우이므로 `n = 2`는 그냥 `n = 1`인 경우에서 첫 번째 부분만 빼고 복사 붙여넣기 하면 되기 때문입니다.

---------------------------------------

# 출력결과 22

## 문제 설명

```cpp

int f(int x, int L) { 
    return 2 * L - x;
}
int main() {
    int i, x = 1;
    for (i = 0; i < 6; i++) {
        x = f(x, -i);
        x = f(x, i); 
    }
    cout << x;
    return 0; 
}

```

에서, 출력 결과가 뭐냐고 합니다. 5지선다입니다.

## 풀이

이것도 손으로 써가며 하는 수 밖에 없는 문제입니다. 굳이 팁이 있다고 하면 f가 표현된 방식대로 수식인 $f(x, L) = 2L - x$로 써서 해보면 좋다는 것 뿐이네요. `i`는 0부터 5까지 쭉 대입해보면 답은 61입니다.

---------------------------------------

# 출력결과 66

## 문제 설명

```cpp

int f(int x, int y, int z) {  
    if (x > y) {    
        if (x > z) {      
            return x;    
        }    
        else {      
            return z;    
        }  
    }  
    else {   
        if (y > z) {     
            return y;   
        }   
        else {     
            return z;   
        }  
    }
}
int main() {  
    cout << f(2, 3, 4) << " " << f(4, 3, 2) << " " << f(3, 2, 4) << endl;
    return 0;
}


```

에서, 출력 결과가 뭐냐고 합니다. 5지선다입니다.

## 풀이

얘는 세 수를 주고 `x`가 `y`보다 크면 `x`와 `z`를 비교하고, `x`가 `y`보다 크지 않으면 `y`와 `z`를 비교합니다. 정답은 `4 4 4`네요. 이는 사실 최댓값을 반환하는 함수였다고 합니다. 즉, 다시 보면 `x`와 `y`를 비교해서 `x`가 더 작으면 일단 최댓값은 확실히 아니니 볼 필요가 없게 됩니다. 그런 식으로 생각해보면 최댓값을 반환하는 함수라는 걸 쉽게 납득할 수 있게 됩니다.